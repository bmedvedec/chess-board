"""
Move History Panel
------------------
Scrollable panel for displaying chess move history in Standard Algebraic Notation.
"""

import pygame
from typing import List, Tuple
from gui.colors import Colors


class MoveHistoryPanel:
    """
    Scrollable panel for displaying chess move history in SAN notation.

    This class creates and manages a vertical panel that displays the complete
    game move history in traditional chess notation. Moves are shown in pairs
    (White and Black on the same line) with automatic move numbering. The panel
    supports scrolling for long games and can optionally highlight the current move.
    """

    def __init__(
        self,
        screen: pygame.Surface,
        x: int,
        y: int,
        width: int,
        height: int,
    ):
        """
        Initialize move history panel with position and dimensions.

        Creates the panel with all necessary fonts, layout calculations, and
        scrolling state. The panel is ready to display moves immediately after
        initialization.

        Args:
            screen (pygame.Surface): Main pygame display surface.
                Used for rendering panel contents and text.

            x (int): X-coordinate of panel's top-left corner.
                Typically positioned in game sidebar (e.g., 850 for right side).

            y (int): Y-coordinate of panel's top-left corner.
                Vertical positioning in sidebar (e.g., 100 for below controls).

            width (int): Panel width in pixels.
                Should match sidebar width, typically 180-220 pixels.
                Must be wide enough for move text (minimum ~160px).

            height (int): Panel height in pixels.
                Determines how many moves are visible at once.
                Typical range: 300-500 pixels for comfortable viewing.
        """
        # Store display surface reference
        self.screen = screen

        # Create panel boundary rectangle for rendering and collision
        # Defines the entire panel area including border
        self.rect = pygame.Rect(x, y, width, height)

        # -------------------- Font Setup --------------------

        # Title font
        self.title_font = pygame.font.SysFont("Arial", 18, bold=True)

        # Move font
        self.move_font = pygame.font.SysFont("Courier New", 14)

        # -------------------- Scrolling Configuration --------------------

        # Current scroll position in number of lines
        # 0 = top of history, increases as scrolling down
        self.scroll_offset: int = 0

        # Vertical spacing between move lines
        self.line_height = 20

        # Calculate how many move pairs fit in visible area
        self.visible_lines = (height - 50) // self.line_height

        # -------------------- Layout Constants --------------------

        # Inner padding from panel edges
        self.padding = 10

    def draw(self, move_history_san: List[str], current_move_number: int = -1):
        """
        Render the complete move history panel with all visual elements.

        This is the main rendering method that should be called every frame.
        It handles all drawing phases: background, title, separator, moves,
        scrollbar, and the current move highlighting.

        Args:
            move_history_san (List[str]): Complete move history in SAN format.
                Flat list of moves in play order: ["e4", "e5", "Nf3", "Nc6", ...]
                White and Black moves alternate in the list.
                Generated by BoardState.get_move_history_san().

            current_move_number (int, optional): Index of move to highlight.
                - -1: No highlighting (default)
                - 0: Highlight first move (White's first move)
                - 1: Highlight second move (Black's first move)
                - 2: Highlight third move (White's second move)
                Useful for move navigation and game replay features.
                Defaults to -1 (no highlighting).
        """
        # -------------------- Background and Border --------------------

        # Draw panel background
        pygame.draw.rect(self.screen, Colors.BACKGROUND, self.rect)

        # Draw panel border
        # Defines panel boundaries and provides visual separation
        pygame.draw.rect(self.screen, Colors.BORDER, self.rect, 2)

        # -------------------- Title --------------------

        # Render "Move History" title text
        title = self.title_font.render("Move History", True, Colors.COORDINATE_TEXT)

        # Center title horizontally at top of panel
        title_rect = title.get_rect(
            centerx=self.rect.centerx, y=self.rect.y + self.padding
        )

        # Draw title to screen
        self.screen.blit(title, title_rect)

        # -------------------- Separator Line --------------------

        # Calculate Y position for horizontal separator
        separator_y = self.rect.y + 35

        # Draw thin horizontal line separating title from moves
        pygame.draw.line(
            self.screen,
            Colors.BORDER,
            (self.rect.x + self.padding, separator_y),
            (self.rect.right - self.padding, separator_y),
            1,
        )

        # -------------------- Handle Empty Move List --------------------

        # Check if game has no moves yet
        if not move_history_san:
            # Render placeholder text in gray
            no_moves_text = self.move_font.render("No moves yet", True, (150, 150, 150))

            # Center placeholder below separator
            no_moves_rect = no_moves_text.get_rect(
                centerx=self.rect.centerx, y=separator_y + 30
            )

            # Draw placeholder
            self.screen.blit(no_moves_text, no_moves_rect)

            # Exit early - no moves to render
            return

        # -------------------- Format Moves into Pairs --------------------

        # Convert flat move list into traditional paired format
        # Input:  ["e4", "e5", "Nf3", "Nc6", "Bb5"]
        # Output: [(1, "e4", "e5"), (2, "Nf3", "Nc6"), (3, "Bb5", "")]
        move_pairs = []
        for i in range(0, len(move_history_san), 2):
            # Calculate move number (1, 2, 3, ...)
            # Each pair represents one full move (White + Black)
            move_num = (i // 2) + 1

            # Get White's move
            white_move = move_history_san[i]

            # Get Black's move if it exists
            black_move = (
                move_history_san[i + 1] if i + 1 < len(move_history_san) else ""
            )

            # Store as tuple: (move_number, white_move, black_move)
            move_pairs.append((move_num, white_move, black_move))

        # -------------------- Scroll Position Calculation --------------------

        # Calculate total number of lines to display
        # Each move pair occupies one line
        total_lines = len(move_pairs)

        # Calculate maximum valid scroll position
        max_scroll = max(0, total_lines - self.visible_lines)

        # Clamp scroll offset to valid range
        # Prevents scrolling too far down
        self.scroll_offset = int(min(self.scroll_offset, max_scroll))

        # Auto-scroll feature: stick to bottom when at or near bottom
        # If user is viewing latest moves, keep showing latest as new moves arrive
        if self.scroll_offset >= max_scroll - 1:
            self.scroll_offset = max_scroll

        # -------------------- Calculate Visible Move Window --------------------

        # Starting Y position for first visible move
        y_offset = separator_y + 10

        # Calculate which moves are visible in current scroll position
        start_idx = int(self.scroll_offset)

        # Calculate end index (non-inclusive)
        end_idx = min(start_idx + self.visible_lines, total_lines)

        # -------------------- Render Visible Moves --------------------

        # Iterate through only the visible move pairs
        # Performance optimization - don't render off-screen moves
        for i in range(start_idx, end_idx):
            # Unpack move pair data
            move_num, white_move, black_move = move_pairs[i]
            # Check if this is the current move for highlighting

            # Determine if this move pair contains the current move
            is_current = current_move_number >= 0 and (
                current_move_number == i * 2 or current_move_number == i * 2 + 1
            )

            # Draw highlight background if current move
            if is_current:
                # Create rectangle for highlight background
                highlight_rect = pygame.Rect(
                    self.rect.x + self.padding,
                    y_offset - 2,
                    self.rect.width - 2 * self.padding,
                    self.line_height,
                )

                # Draw blue-gray background for current move
                pygame.draw.rect(self.screen, (80, 80, 100), highlight_rect)

            # Format move line with proper alignment

            # Create formatted move string with fixed-width columns
            move_line = f"{move_num:>3}. {white_move:<8} {black_move:<8}"

            # Render move text

            # Choose text color based on highlight state
            move_color = Colors.COORDINATE_TEXT if not is_current else (255, 255, 255)

            # Render the formatted move line
            # Anti-aliasing (True) makes text smooth
            move_text = self.move_font.render(move_line, True, move_color)

            # Position text with padding from left edge and small additional offset
            move_rect = move_text.get_rect(x=self.rect.x + self.padding + 5, y=y_offset)

            # Clip text to panel bounds

            # Stop rendering if we've reached the bottom of panel
            # Prevents text from overflowing panel boundaries
            if move_rect.bottom > self.rect.bottom - self.padding:
                break

            # Draw the move text
            self.screen.blit(move_text, move_rect)

            # Advance Y position for next move line
            y_offset += self.line_height

        # -------------------- Draw Scrollbar If Needed --------------------

        # Only show scrollbar if there are more moves than visible lines
        if total_lines > self.visible_lines:
            self._draw_scrollbar(total_lines)

    def _draw_scrollbar(self, total_lines: int):
        """
        Draw visual scrollbar indicator on right edge of panel.

        Args:
            total_lines (int): Total number of move pairs in history.
                Used to calculate thumb size and position.
        """
        # Scrollbar dimensions
        scrollbar_width = 8

        # Position scrollbar at right edge with small margin
        scrollbar_x = self.rect.right - scrollbar_width - 5

        # Start below title and separator
        scrollbar_y = self.rect.y + 45

        # Height extends to near panel bottom
        scrollbar_height = self.rect.height - 55

        # Draw background track

        # Create rectangle for scrollbar track
        track_rect = pygame.Rect(
            scrollbar_x, scrollbar_y, scrollbar_width, scrollbar_height
        )

        # Fill track with dark gray
        # Represents the full scrollable range
        pygame.draw.rect(self.screen, (60, 60, 60), track_rect)

        # Calculate thumb (draggable indicator) size

        # Thumb height is proportional to visible/total ratio
        thumb_ratio = self.visible_lines / total_lines
        thumb_height = max(20, int(scrollbar_height * thumb_ratio))
        # Minimum 20px ensures thumb is always grabbable/visible

        # Calculate thumb vertical position

        # Calculate scroll progress (0.0 to 1.0)
        scroll_ratio = self.scroll_offset / max(1, total_lines - self.visible_lines)

        # Position thumb within available track space
        thumb_y = scrollbar_y + int((scrollbar_height - thumb_height) * scroll_ratio)

        # Draw thumb

        # Create rectangle for thumb
        thumb_rect = pygame.Rect(scrollbar_x, thumb_y, scrollbar_width, thumb_height)

        # Fill thumb with lighter gray
        pygame.draw.rect(self.screen, (120, 120, 120), thumb_rect)

        # Draw border around thumb for definition
        pygame.draw.rect(self.screen, Colors.BORDER, thumb_rect, 1)

    def scroll_up(self, lines: int = 1):
        """
        Scroll up (toward earlier moves) by specified number of lines.

        Args:
            lines (int, optional): Number of move pairs to scroll up.
                Defaults to 1 (one line at a time).
        """
        # Decrease offset (move toward start of history)
        # max() prevents scrolling past first move
        self.scroll_offset = max(0, self.scroll_offset - lines)

    def scroll_down(self, lines: int = 1):
        """
        Scroll down (toward later moves) by specified number of lines.

        Args:
            lines (int, optional): Number of move pairs to scroll down.
                Defaults to 1 (one line at a time).
        """
        # Increase offset (move toward end of history)
        # Clamping to max happens in draw() method
        self.scroll_offset += lines

    def scroll_to_bottom(self):
        """
        Jump to bottom of move history to show most recent moves.
        """
        # Set to large number that exceeds any reasonable game length
        # draw() method will clamp this to max_scroll automatically
        self.scroll_offset = 999999

    def scroll_to_top(self):
        """
        Jump to top of move history to show first moves of the game.
        """
        # Reset to beginning of history
        self.scroll_offset = 0

    def handle_mouse_wheel(self, y_delta: int):
        """
        Process mouse wheel scrolling event.

        Args:
            y_delta (int): Mouse wheel delta from pygame.MOUSEWHEEL event.
                - Positive values: Wheel scrolled up (scroll panel up)
                - Negative values: Wheel scrolled down (scroll panel down)
                - Magnitude usually 1 per wheel notch
        """
        # Wheel up: scroll toward earlier moves
        if y_delta > 0:
            self.scroll_up(3)  # 3 lines per notch

        # Wheel down: scroll toward later moves
        elif y_delta < 0:
            self.scroll_down(3)  # 3 lines per notch

    def is_mouse_over(self, pos: Tuple[int, int]) -> bool:
        """
        Check if mouse cursor is currently over this panel.

        Used to determine whether to process mouse wheel events for this panel.
        Prevents scrolling unintended panels when mouse is elsewhere.

        Args:
            pos (Tuple[int, int]): Mouse position as (x, y) coordinates.
                Typically from pygame.mouse.get_pos().

        Returns:
            bool: True if mouse is within panel boundaries, False otherwise.
        """
        # Use pygame's collision detection on panel rectangle
        # Returns True if point is inside rect
        return self.rect.collidepoint(pos)
