"""
Move History Panel
------------------
Scrollable panel for displaying chess move history in Standard Algebraic Notation.
"""

import pygame
from typing import List, Optional, Tuple
from gui.colors import Colors


class MoveHistoryPanel:
    """
    Scrollable panel for displaying chess move history in SAN notation.

    This class creates and manages a vertical panel that displays the complete
    game move history in traditional chess notation. Moves are shown in pairs
    (White and Black on the same line) with automatic move numbering. The panel
    supports scrolling for long games and can optionally highlight the current move.
    Supported click navigation for move selection as well.
    """

    def __init__(
        self,
        screen: pygame.Surface,
        x: int,
        y: int,
        width: int,
        height: int,
    ):
        """
        Initialize move history panel with position and dimensions.

        Creates the panel with all necessary fonts, layout calculations, and
        scrolling state. The panel is ready to display moves immediately after
        initialization.

        Args:
            screen (pygame.Surface): Main pygame display surface.
                Used for rendering panel contents and text.

            x (int): X-coordinate of panel's top-left corner.
                Typically positioned in game sidebar (e.g., 850 for right side).

            y (int): Y-coordinate of panel's top-left corner.
                Vertical positioning in sidebar (e.g., 100 for below controls).

            width (int): Panel width in pixels.
                Should match sidebar width, typically 180-220 pixels.
                Must be wide enough for move text (minimum ~160px).

            height (int): Panel height in pixels.
                Determines how many moves are visible at once.
                Typical range: 300-500 pixels for comfortable viewing.
        """
        # Store display surface reference
        self.screen = screen

        # Create panel boundary rectangle for rendering and collision
        # Defines the entire panel area including border
        self.rect = pygame.Rect(x, y, width, height)

        # -------------------- Font Setup --------------------

        # Title font
        self.title_font = pygame.font.SysFont("Arial", 18, bold=True)

        # Move font
        self.move_font = pygame.font.SysFont("Courier New", 14)

        # -------------------- Scrolling Configuration --------------------

        # Current scroll position in number of lines
        # 0 = top of history, increases as scrolling down
        self.scroll_offset: int = 0

        # Vertical spacing between move lines
        self.line_height = 20

        # Calculate how many move pairs fit in visible area
        self.visible_lines = (height - 50) // self.line_height

        # -------------------- Layout Constants --------------------

        # Inner padding from panel edges
        self.padding = 10

        # Y position where moves start (after title and separator)
        self.moves_start_y = 45

        # -------------------- Move selection tracking --------------------
        self.selected_move_index: Optional[int] = None  # Index in flat move list
        self.hover_move_index: Optional[int] = None  # For hover effects

    def draw(self, move_history_san: List[str], current_move_number: int = -1):
        """
        Render the complete move history panel with all visual elements.

        This is the main rendering method that should be called every frame.
        It handles all drawing phases: background, title, separator, moves,
        scrollbar, and the current move highlighting.

        Args:
            move_history_san (List[str]): Complete move history in SAN format.
                Flat list of moves in play order: ["e4", "e5", "Nf3", "Nc6", ...]
                White and Black moves alternate in the list.
                Generated by BoardState.get_move_history_san().

            current_move_number (int, optional): Index of move to highlight.
                - -1: No highlighting (default)
                - 0: Highlight first move (White's first move)
                - 1: Highlight second move (Black's first move)
                - 2: Highlight third move (White's second move)
                Useful for move navigation and game replay features.
                Defaults to -1 (no highlighting).
        """
        # -------------------- Background and Border --------------------

        # Draw panel background
        pygame.draw.rect(self.screen, Colors.BACKGROUND, self.rect)

        # Draw panel border
        # Defines panel boundaries and provides visual separation
        pygame.draw.rect(self.screen, Colors.BORDER, self.rect, 2)

        # -------------------- Title --------------------

        # Render "Move History" title text
        title = self.title_font.render("Move History", True, Colors.COORDINATE_TEXT)

        # Center title horizontally at top of panel
        title_rect = title.get_rect(
            centerx=self.rect.centerx, y=self.rect.y + self.padding
        )

        # Draw title to screen
        self.screen.blit(title, title_rect)

        # -------------------- Separator Line --------------------

        # Calculate Y position for horizontal separator
        separator_y = self.rect.y + 35

        # Draw thin horizontal line separating title from moves
        pygame.draw.line(
            self.screen,
            Colors.BORDER,
            (self.rect.x + self.padding, separator_y),
            (self.rect.right - self.padding, separator_y),
            1,
        )

        # -------------------- Handle Empty Move List --------------------

        # Check if game has no moves yet
        if not move_history_san:
            # Render placeholder text in gray
            no_moves_text = self.move_font.render("No moves yet", True, (150, 150, 150))

            # Center placeholder below separator
            no_moves_rect = no_moves_text.get_rect(
                centerx=self.rect.centerx, y=separator_y + 30
            )

            # Draw placeholder
            self.screen.blit(no_moves_text, no_moves_rect)

            # Exit early - no moves to render
            return

        # -------------------- Format Moves into Pairs --------------------

        # Convert flat move list into traditional paired format
        # Input:  ["e4", "e5", "Nf3", "Nc6", "Bb5"]
        # Output: [(1, "e4", "e5"), (2, "Nf3", "Nc6"), (3, "Bb5", "")]
        move_pairs = []
        for i in range(0, len(move_history_san), 2):
            # Calculate move number (1, 2, 3, ...)
            # Each pair represents one full move (White + Black)
            move_num = (i // 2) + 1

            # Get White's move
            white_move = move_history_san[i]

            # Get Black's move if it exists
            black_move = (
                move_history_san[i + 1] if i + 1 < len(move_history_san) else ""
            )

            # Store as tuple: (move_number, white_move, black_move)
            move_pairs.append((move_num, white_move, black_move))

        # -------------------- Scroll Position Calculation --------------------

        # Calculate total number of lines to display
        # Each move pair occupies one line
        total_lines = len(move_pairs)

        # Calculate maximum valid scroll position
        max_scroll = max(0, total_lines - self.visible_lines)

        # Clamp scroll offset to valid range
        # Prevents scrolling too far down
        self.scroll_offset = int(min(self.scroll_offset, max_scroll))

        # Auto-scroll feature: stick to bottom when at or near bottom
        # If user is viewing latest moves, keep showing latest as new moves arrive
        if self.scroll_offset >= max_scroll - 1:
            self.scroll_offset = max_scroll

        # -------------------- Calculate Visible Move Window --------------------

        # Starting Y position for first visible move
        y_offset = separator_y + 10

        # Calculate which moves are visible in current scroll position
        start_idx = int(self.scroll_offset)

        # Calculate end index (non-inclusive)
        end_idx = min(start_idx + self.visible_lines, total_lines)

        # Get current mouse position for hover detection
        mouse_pos = pygame.mouse.get_pos()
        self.hover_move_index = None

        # -------------------- Render Visible Moves --------------------

        # Iterate through only the visible move pairs
        # Performance optimization - don't render off-screen moves
        for i in range(start_idx, end_idx):
            # Unpack move pair data
            move_num, white_move, black_move = move_pairs[i]

            # Determine if this move pair contains the current move
            is_current = current_move_number >= 0 and (
                current_move_number == i * 2 or current_move_number == i * 2 + 1
            )

            # Create rectangle for this move line (for click detection)
            move_line_rect = pygame.Rect(
                self.rect.x + self.padding,
                y_offset - 2,
                self.rect.width - 2 * self.padding,
                self.line_height,
            )

            # Check if mouse is hovering over this line
            is_hovering = move_line_rect.collidepoint(mouse_pos)

            # Hover highlight
            if is_hovering:
                pygame.draw.rect(self.screen, (70, 70, 80), move_line_rect)
                # Track which move(s) are being hovered
                self.hover_move_index = i * 2

            # Draw highlight background if current move
            if is_current:
                # Draw blue-gray background for current move
                pygame.draw.rect(self.screen, (80, 80, 100), move_line_rect)

            # Render move number
            move_num_text = f"{move_num:>3}."
            move_num_surface = self.move_font.render(
                move_num_text, True, Colors.COORDINATE_TEXT
            )
            self.screen.blit(
                move_num_surface, (self.rect.x + self.padding + 5, y_offset)
            )

            # Render White's move
            white_move_surface = self.move_font.render(
                white_move, True, Colors.TEXT_PRIMARY
            )
            self.screen.blit(
                white_move_surface, (self.rect.x + self.padding + 50, y_offset)
            )

            # Render Black's move (if exists)
            if black_move:
                black_move_surface = self.move_font.render(
                    black_move, True, Colors.TEXT_PRIMARY
                )
                self.screen.blit(
                    black_move_surface, (self.rect.x + self.padding + 130, y_offset)
                )

            # Move to next line
            y_offset += self.line_height

        # -------------------- Draw Scrollbar --------------------

        # Only show scrollbar if content exceeds visible area
        if total_lines > self.visible_lines:
            self._draw_scrollbar(total_lines)

    def _draw_scrollbar(self, total_lines: int):
        """
        Draw scrollbar indicator for navigating long move lists.

        Creates a visual scrollbar on the right edge of the panel showing
        current scroll position and available scroll range. The scrollbar
        thumb size is proportional to visible/total ratio.

        Args:
            total_lines (int): Total number of move pairs in history.
                Used to calculate thumb size and position.
        """
        # Scrollbar dimensions
        scrollbar_width = 8

        # Position scrollbar at right edge with small margin
        scrollbar_x = self.rect.right - scrollbar_width - 5

        # Start below title and separator
        scrollbar_y = self.rect.y + 45

        # Height extends to near panel bottom
        scrollbar_height = self.rect.height - 55

        # Draw background track

        # Create rectangle for scrollbar track
        track_rect = pygame.Rect(
            scrollbar_x, scrollbar_y, scrollbar_width, scrollbar_height
        )

        # Fill track with dark gray
        # Represents the full scrollable range
        pygame.draw.rect(self.screen, (60, 60, 60), track_rect)

        # Calculate thumb (draggable indicator) size

        # Thumb height is proportional to visible/total ratio
        thumb_ratio = self.visible_lines / total_lines
        thumb_height = max(20, int(scrollbar_height * thumb_ratio))
        # Minimum 20px ensures thumb is always grabbable/visible

        # Calculate thumb vertical position

        # Calculate scroll progress (0.0 to 1.0)
        scroll_ratio = self.scroll_offset / max(1, total_lines - self.visible_lines)

        # Position thumb within available track space
        thumb_y = scrollbar_y + int((scrollbar_height - thumb_height) * scroll_ratio)

        # Draw thumb

        # Create rectangle for thumb
        thumb_rect = pygame.Rect(scrollbar_x, thumb_y, scrollbar_width, thumb_height)

        # Fill thumb with lighter gray
        pygame.draw.rect(self.screen, (120, 120, 120), thumb_rect)

        # Draw border around thumb for definition
        pygame.draw.rect(self.screen, Colors.BORDER, thumb_rect, 1)

    def handle_click(self, pos: Tuple[int, int]) -> Optional[int]:
        """
        Handle click on move to navigate to that position.

        Args:
            pos: Mouse click position (x, y)

        Returns:
            Optional[int]: Move index (0-based in flat list) if clicked, None otherwise
        """
        # Check if click is within panel
        if not self.rect.collidepoint(pos):
            return None

        # Calculate Y position where moves start
        separator_y = self.rect.y + 35
        moves_start_y = separator_y + 10
        click_y = pos[1]

        # Check if click is in the moves area
        if click_y < moves_start_y:
            return None

        # Calculate relative position within the visible moves area
        # Note: Drawing code uses y_offset - 2 for rect positioning, so we match that
        relative_y = click_y - (moves_start_y - 2)

        # Calculate which visible line was clicked (0-indexed from top of visible area)
        line_clicked = relative_y // self.line_height

        # Calculate the actual move pair index accounting for scroll
        move_pair_index = int(self.scroll_offset) + line_clicked

        # Calculate x position to determine white vs black move
        click_x = pos[0]

        # Layout constants (should match drawing code)
        move_number_width = 45  # Width allocated for move number "  1."
        white_move_start = self.rect.x + self.padding + move_number_width
        white_move_width = 75  # Approximate width of white move column

        # Determine if clicked on white or black move
        if click_x < white_move_start + white_move_width:
            # Clicked on white's move
            move_index = move_pair_index * 2
        else:
            # Clicked on black's move
            move_index = move_pair_index * 2 + 1

        # Store selected move
        self.selected_move_index = move_index

        return move_index

    def scroll_up(self, lines: int = 1):
        """
        Scroll up (toward earlier moves) by specified number of lines.

        Args:
            lines (int, optional): Number of move pairs to scroll up.
                Defaults to 1 (one line at a time).
        """
        # Decrease offset (move toward start of history)
        # max() prevents scrolling past first move
        self.scroll_offset = max(0, self.scroll_offset - lines)

    def scroll_down(self, lines: int = 1):
        """
        Scroll down (toward later moves) by specified number of lines.

        Args:
            lines (int, optional): Number of move pairs to scroll down.
                Defaults to 1 (one line at a time).
        """
        # Increase offset (move toward end of history)
        # Clamping to max happens in draw() method
        self.scroll_offset += lines

    def scroll_to_bottom(self):
        """
        Jump to bottom of move history to show most recent moves.
        """
        # Set to large number that exceeds any reasonable game length
        # draw() method will clamp this to max_scroll automatically
        self.scroll_offset = 999999

    def scroll_to_top(self):
        """
        Jump to top of move history to show first moves of the game.
        """
        # Reset to beginning of history
        self.scroll_offset = 0

    def handle_mouse_wheel(self, y_delta: int):
        """
        Process mouse wheel scrolling event.

        Args:
            y_delta (int): Mouse wheel delta from pygame.MOUSEWHEEL event.
                - Positive values: Wheel scrolled up (scroll panel up)
                - Negative values: Wheel scrolled down (scroll panel down)
                - Magnitude usually 1 per wheel notch
        """
        # Wheel up: scroll toward earlier moves
        if y_delta > 0:
            self.scroll_up(3)  # 3 lines per notch

        # Wheel down: scroll toward later moves
        elif y_delta < 0:
            self.scroll_down(3)  # 3 lines per notch

    def is_mouse_over(self, pos: Tuple[int, int]) -> bool:
        """
        Check if mouse cursor is currently over this panel.

        Used to determine whether to process mouse wheel events for this panel.
        Prevents scrolling unintended panels when mouse is elsewhere.

        Args:
            pos (Tuple[int, int]): Mouse position as (x, y) coordinates.
                Typically from pygame.mouse.get_pos().

        Returns:
            bool: True if mouse is over panel, False otherwise
        """
        return self.rect.collidepoint(pos)
